#include <iostream> 

using namespace std;


 
template<class T>
class SmartPtr
{
	T* ptr;
public:
	// Получаем указатель для "владения" через конструктор
	// SmartPtr теперь имеет композиционную связь с ptr и
	// полностью управляет жизненым циклом данного указателя
	SmartPtr(T* ptr=nullptr)
		:ptr(ptr)
	{
	}
	
	// Деструктор позаботится об удалении указателя
	~SmartPtr()
	{
		delete ptr;
	}
 
	// Выполняем перегрузку оператора разыменования и оператора ->, 
	// чтобы иметь возможность использовать SmartPtr как обычный указатель 
	T& operator*() const { return *ptr; }
	T* operator->() const { return ptr; }
	
	/*
	// Конструктор копирования, который реализует семантику перемещения
	SmartPtr(SmartPtr& a) // Ссылка не является константной!
	{
		ptr = a.ptr; // перемещаем указатель от источника к приёмнику
		a.ptr = nullptr; // источник больше не владеет указателем
	}
	
	// Оператор присваивания, который реализовывает семантику перемещения
	SmartPtr& operator=(SmartPtr& a) // примечание: Ссылка не является константной
	{
		if (&a == this)
			return *this;
 
		delete ptr; // удаляем любой указатель, который наш объект имел до этого
		ptr = a.ptr; // перемещаем указатель от источника к приёмнику
		a.ptr = nullptr; // источник больше не владеет указателем
		return *this;
	}
	//*/
};
 
// Класс для проверки работы умного указателя
class MyClass
{
	string name;
public:
    MyClass(const string& name) : name(name) 
	{ 
		cout << name << " создан!" << endl; 
	}
	
    ~MyClass() 
	{ 
		cout << name << " уничтожен!" << endl; 
	}
};
 

/* 
по умолчанию конструктор копии выполняет поверхностное копирование
значит после передачи указателя по значению произойдёт копирование объекта obj1 в param
и следовательно они будут указывать на одно и то же место в памяти.
После выхода param из области видимости он очистит указатель, но тогда получается
что obj1 в свою очередь будет очищать уже очищенную param память, и произойдёт
ошибка!
*/
void smartPtrByValue(SmartPtr<MyClass> param)
{
} // здесь param будет удалён!
 
int main(int argc, char** argv)
{
	system("chcp 1251");

	SmartPtr<MyClass> obj1(new MyClass(string("Объект 1")));
	smartPtrByValue(obj1);
	
	
	/*
	та же проблема возникнет при возвращении по значению из функции.
	Мы не можем вернуть SmartPtr по ссылке, т.к. локальный объект
	будет уничтожен в конце функции и возвращёная ссылка уже будет указывать
	на удалёную память.
	Возврат по адресу имеет ту же проблему.
	Возврат по значению приведет к поверхностному копированию
	и созданию объекта SmartPtr с уже очищенным указателем.
	
	??? generateItem()
	{
	     Item *item = new Item;
	     return Auto_ptr1(item);
	}
	
	каков же выход? Нужно реализовать "семантику перемещения", т.е.
	переопределить конструктор копии и оператор присваивания для SmartPtr
	и передавать владение указаетлем из источника в объект назначения.
	
	*/
	
	cout << "конец программы" << endl;
	

	return 0;
} 

